# DDD 애그리거트 설계, 아직도 뇌절이 온다면? (실전 예제: Reservation) by Gemini

DDD 스터디를 진행하면서 코드 레벨의 책임 분리(Controller, UseCase, Repository 등)는 어느 정도 감을 잡았지만, 정작 가장 중요한 도메인 모델링, 특히 **"이 엔티티들을 어떻게 묶고 나눠야 하는가?"** 에서 뇌정지가 오는 경우가 많습니다. 저 또한 그랬습니다.

이 문서는 애그리거트(Aggregate)와 애그리거트 루트(Aggregate Root)의 개념을 딱딱한 정의가 아닌, 실전적인 질문과 예시를 통해 이해하고, 이를 바탕으로 `Reservation`(예매) 애그리거트를 설계하기까지의 사고 과정을 기록한 문서입니다.

---

## ⚙️ 1. 왜 '애그리거트'로 묶어야 할까?

만약 모든 엔티티가 서로 자유롭게 참조하고, 아무 서비스나 Repository에서 엔티티의 상태를 마음대로 바꿀 수 있다면 어떻게 될까요? 시스템은 순식간에 무엇이 어디서 어떻게 바뀌는지 추적할 수 없는 **"거대한 진흙 덩어리(Big Ball of Mud)"** 가 됩니다.

**애그리거트의 핵심 목적은 '데이터 변경의 일관성을 보장하는 경계'를 만드는 것입니다.**

-   **트랜잭션 경계**: 애그리거트 내의 변경은 하나의 트랜잭션으로 처리되어야 합니다. 즉, 애그리거트 전체가 일관된 상태를 유지하거나, 아니면 아예 변경되지 않아야 합니다. (All or Nothing)
-   **규칙 강제**: "예매 총액은 모든 예매 항목(좌석)의 가격 합과 같아야 한다"와 같은 **비즈니스 규칙(불변성, Invariant)** 은 애그리거트라는 경계 안에서만 책임지고 검증합니다.

애그리거트는 이 경계 안의 객체들을 외부로부터 보호하는 '방어막' 역할을 합니다.

## 🧭 2. 애그리거트 루트(Aggregate Root)는 어떻게 찾을까?

애그리거트라는 '방어막'의 유일한 '문(Gate)'이 바로 **애그리거트 루트**입니다. 외부에서는 오직 루트를 통해서만 애그리거트 내부의 객체에 접근하고 로직을 실행할 수 있습니다.

그럼 어떤 엔티티가 루트가 될 자격이 있을까요?

-   **Rule #1: 고유한 식별성을 가지고, 독립적으로 존재할 수 있는가?**
    -   `Member`(회원), `Game`(경기), `Team`(팀)은 모두 각자 존재할 수 있습니다. 우리는 `memberRepository.findById()` 처럼 이들을 직접 조회할 수 있습니다. 이들은 모두 각자의 애그리거트 루트가 될 자격이 충분합니다.
    -   반면, `ReservationItem`(예매 항목, 예: A좌석 1매)이 `Reservation`(예매) 정보 없이 독립적으로 존재할 수 있을까요? 불가능합니다. 따라서 `ReservationItem`은 루트가 될 수 없습니다.

-   **Rule #2: 시스템의 다른 부분에서 주로 이 객체를 참조하는가?**
    -   '알림' 도메인에서 특정 예매에 대해 알림을 보낼 때, `Reservation`의 ID를 참조할까요, 아니면 그 안의 특정 `ReservationItem`의 ID를 참조할까요? 당연히 `Reservation` ID를 참조합니다. 이처럼 애그리거트 루트는 애그리거트 전체를 대표하는 식별성을 가집니다.

-   **Rule #3: 내부 구성원의 생명주기(Lifecycle)를 관리하는가?**
    -   `Reservation`이 생성될 때 `ReservationItem`들이 함께 생성되고, `Reservation`이 취소되면 `ReservationItem`들도 함께 상태가 바뀝니다. 이처럼 루트는 내부 객체들의 생성, 변경, 삭제를 총괄합니다.

## 🧰 3. 무엇을 애그리거트 안에 넣고, 무엇을 밖에 둘까?

이것이 모델링의 핵심입니다.

-   **안에 두는 것 (내부 엔티티 / VO)**: 루트 없이는 존재 의미가 없는 것들입니다. 생명주기가 루트에 완전히 종속됩니다.
    -   **예시**: `ReservationItem`은 `Reservation`에 속합니다. `Address`(주소)는 `Member`에 속하는 값 객체(Value Object)입니다.

-   **밖에 두는 것 (별개의 애그리거트)**: 각자 독립적인 생명주기를 가지는 것들입니다.
    -   **예시**: `Game`은 `Reservation`이 없어도 존재합니다. `Member`도 마찬가지입니다. 따라서 이들은 별개의 애그리거트입니다.

-   **핵심 원칙: 어떻게 연결할 것인가? → ID로 참조하라!**
    -   `Reservation` 애그리거트가 `Game` 애그리거트를 참조해야 할 때, `@ManyToOne` 같은 ORM의 객체 참조를 사용하는 것이 아니라, `gameId: Long` 처럼 ID 값만 갖는 것이 좋습니다.
    -   **왜?** 객체 참조는 두 애그리거트를 강하게 결합시켜, 한쪽의 변경이 다른 쪽에 영향을 미치게 만듭니다. ID 참조는 이 결합을 끊어 각 애그리거트의 독립성을 보장해 줍니다. (우리가 `Team`에서 `Game` 목록을 제거한 것과 같은 원리입니다.)

---

## 💡 실전! `Reservation` 애그리거트 설계 사고 과정

이제 위 원칙들을 바탕으로, `Reservation` 애그리거트를 설계해 보겠습니다.

1.  **핵심 개념 식별**: 우리 시스템에서 '예매'는 독립적으로 생성되고, 조회되고, 취소될 수 있는 핵심 도메인 개념입니다. 따라서 `Reservation`은 애그리거트 루트가 될 강력한 후보입니다.

2.  **필요한 정보 정의 (질문 던지기)**:
    -   **누가** 예매했는가? → `Member` 정보가 필요하다. 하지만 `Member`는 독립적인 애그리거트이므로, 객체 전체가 아닌 `memberId: Long`만 참조한다.
    -   **무슨 경기**를 예매했는가? → `Game` 정보가 필요하다. `Game` 역시 독립적인 애그리거트이므로, `gameId: Long`만 참조한다.
    -   **예매 상태**는 무엇인가? → '예약 완료', '취소' 등은 `Reservation`의 핵심 상태이다. `ReservationStatus`라는 Enum(열거형)으로 만들어 내부에 둔다.
    -   **어떤 좌석들**을 예매했는가? → `ReservationItem`(예매 항목)은 `Reservation`에 전적으로 종속된다. 따라서 `List<ReservationItem>`은 `Reservation` 애그리거트 내부에 두는 것이 맞다. `Reservation` 루트가 이 목록의 일관성(예: 중복 좌석 불가)을 책임진다.
    -   **결제 정보**는? → `Payment` 역시 `Reservation`을 위해 존재한다. `Payment`는 `Reservation` 애그리거트 내부에 두거나, 결제가 매우 복잡한 도메인이라면 별도의 `Payment` 애그리거트로 분리하고 ID로 참조할 수도 있다. (지금은 내부에 둔다고 가정)

3.  **경계와 책임 정의**:
    -   **루트**: `Reservation`
    -   **내부 구성원**: `ReservationItem`, `Payment`, `ReservationStatus`
    -   **외부 참조 (ID만)**: `Member`, `Game`

4.  **현재 목표에 맞는 최소 기능 설계**:
    -   우리의 당면 과제는 '일자별 경기 목록 조회'에서 '나의 예매 여부'를 확인하는 것입니다. 이 기능을 위해서는 `ReservationItem`이나 `Payment`까지는 아직 필요 없습니다.
    -   단지 **'어떤 `Member`가 어떤 `Game`을 예매했다'** 는 사실을 기록하는 연결고리만 있으면 됩니다.
    -   따라서, 지금 단계에서는 가장 최소한의 정보를 가진 `Reservation` 엔티티를 만드는 것이 합리적입니다.

```kotlin
// 최종적으로 도출된 Reservation 엔티티의 최소 버전

@Entity
class Reservation(
    @Id @GeneratedValue
    val id: Long? = null,

    val memberId: Long, // 어느 회원?

    val gameId: Long, // 무슨 경기?

    @Enumerated(EnumType.STRING)
    val status: ReservationStatus, // 상태는?

    val reservedAt: LocalDateTime // 언제?
)
```

이러한 사고 과정을 통해, 당장 필요한 최소한의 책임을 가지면서도 앞으로 `ReservationItem` 등을 추가하며 확장해 나갈 수 있는 `Reservation` 애그리거트의 뼈대를 설계할 수 있었습니다.
