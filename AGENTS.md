# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Kotlin + Spring Boot study project for learning Domain Driven Development (DDD) methodology. The project implements a ticket reservation system (similar to Interpark) with a focus on proper DDD patterns and hybrid data access strategies.

**Technology Stack:**
- Language: Kotlin 1.9.25
- Framework: Spring Boot 3.5.6
- Java: 21
- Database: MySQL (localhost:3306)
- ORM: Spring Data JPA + MyBatis
- Build Tool: Gradle

## Common Commands

### Build
```bash
./gradlew build
```

### Run Application
```bash
./gradlew bootRun
```

### Run Tests
```bash
./gradlew test
```

### Run Single Test
```bash
./gradlew test --tests "com.innovation.dddexample.ClassName.testMethodName"
```

### Clean Build
```bash
./gradlew clean build
```

## Architecture

This project follows **Domain Driven Development (DDD)** with clear layer separation:

**Bounded Contexts:**
1. **Performance Management** - Í≥µÏó∞, Ï¢åÏÑù, Îì±Í∏â Ï†ïÎ≥¥ Í¥ÄÎ¶¨
2. **Reservation** - ÏòàÎß§, Í≤∞Ï†ú, Ï¢åÏÑù Ï†êÏú† Ï≤òÎ¶¨ (ÎèôÏãúÏÑ± Ï†úÏñ¥ Ï§ëÏöî)
3. **Member** - ÌöåÏõê Ï†ïÎ≥¥, ÏòàÎß§ Ïù¥Î†• Í¥ÄÎ¶¨

**Core Aggregates:**
- **Performance Aggregate**: Performance (Root), Seat, SeatGrade
- **Reservation Aggregate**: Reservation (Root), ReservationItem, Payment
- **Member Aggregate**: Member (Root), Email (Value Object), PhoneNumber (Value Object)

**Layer Structure:**
```
domain/           - Aggregate, Entity, Value Object, Repository interfaces, Domain Services
application/      - Use Case implementations (orchestrates domain logic)
infrastructure/   - Repository implementations (JPA + MyBatis)
interfaces/       - REST API Controllers, DTOs
```

**Key DDD Principles:**
- Each Aggregate has a clear root entity
- Cross-aggregate references use IDs only, not direct object references
- Domain logic resides in domain layer, not application services
- Repository interfaces defined in domain layer, implemented in infrastructure layer

## Concurrency Control Strategy

The reservation system requires careful concurrency handling for seat booking:

1. **Optimistic Lock**: JPA `@Version` on Seat entity for conflict detection
2. **Pessimistic Lock**: Applied where necessary with deadlock prevention
3. Retry logic for handling concurrent booking conflicts

## Data Access Strategy

- **JPA**: Domain model persistence (Performance, Reservation, Member entities)
- **MyBatis**: Complex queries (reservation history, statistics, reporting)

The goal is to understand when to use each approach and how to combine them effectively.

## Package Structure

Base package: `com.innovation.dddexample`

Current structure:
```
com.innovation.dddexample/
‚îú‚îÄ‚îÄ DddExampleApplication.kt           # Main application class
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ member/
‚îÇ       ‚îú‚îÄ‚îÄ model/                      # ‚úÖ Implemented
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Member.kt              # Aggregate Root
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Email.kt               # Value Object
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ PhoneNumber.kt         # Value Object
‚îÇ       ‚îú‚îÄ‚îÄ repository/                # TODO
‚îÇ       ‚îî‚îÄ‚îÄ service/                   # TODO
‚îú‚îÄ‚îÄ application/                       # TODO
‚îú‚îÄ‚îÄ infrastructure/                    # TODO
‚îÇ   ‚îú‚îÄ‚îÄ persistence/                  # JPA implementations
‚îÇ   ‚îî‚îÄ‚îÄ mybatis/                      # MyBatis implementations
‚îî‚îÄ‚îÄ interfaces/                        # TODO
    ‚îú‚îÄ‚îÄ rest/                         # REST controllers
    ‚îî‚îÄ‚îÄ dto/                          # Request/Response DTOs
```

**Naming Convention:**
- `domain/{context}/model/` - Aggregate Root, Entities, Value Objects
- `domain/{context}/repository/` - Repository interfaces (domain layer)
- `domain/{context}/service/` - Domain services
- `application/{context}/` - Application services (use cases)
- `infrastructure/persistence/{context}/` - JPA repository implementations
- `infrastructure/mybatis/{context}/` - MyBatis mapper implementations
- `interfaces/rest/{context}/` - REST API controllers
- `interfaces/dto/{context}/` - Request/Response DTOs

## Development Notes

- This is a **learning project** focused on understanding DDD patterns and Kotlin
- The developer has Java/Spring Boot and Node.js experience but is learning Kotlin
- Emphasis on proper separation of concerns between layers
- Both JPA and MyBatis will be used to compare approaches

## Implementation Status

### ‚úÖ Completed
- Database configuration (MySQL)
- Member Aggregate with Value Objects
  - Member entity (Aggregate Root)
  - Email Value Object (validation, formatting)
  - PhoneNumber Value Object (validation, normalization, masking)
- Package structure refactored to `com.innovation.dddexample`
- Member Repository layer
  - MemberRepository interface (domain layer)
  - MemberJpaRepository (Spring Data JPA)
  - MemberRepositoryImpl (infrastructure layer)

### üöß In Progress
- Member GET API (Reference Implementation)
  - Application service (MemberQueryService)
  - REST controller (MemberController)
  - DTOs and exception handling

## Reference Implementation: Member GET API

**Feature**: GET /api/members/{id} - Retrieve member information by ID

This implementation serves as a **reference pattern** for all future DDD-based APIs in the project.

### Layer-by-Layer Implementation

#### 1. Domain Layer (No changes needed)
- **Member** aggregate already exists with Value Objects
- **MemberRepository** interface defines contract: `fun findById(id: Long): Member?`
- **MemberNotFoundException** domain exception created for not-found scenario

```kotlin
// domain/member/exception/MemberNotFoundException.kt
class MemberNotFoundException(
    memberId: Long
) : RuntimeException("Member not found with id: $memberId")
```

**Key Principle**: Domain layer knows nothing about HTTP, REST, or Spring Web.

#### 2. Infrastructure Layer (Existing)
- **MemberRepositoryImpl** implements domain interface
- Delegates to **MemberJpaRepository** (Spring Data JPA)
- Converts JPA `Optional<Member>` to Kotlin nullable `Member?`

**Key Principle**: Infrastructure knows about JPA but domain doesn't.

#### 3. Application Layer (New)
- **MemberQueryService** orchestrates the use case

```kotlin
// application/member/MemberQueryService.kt
@Service
@Transactional(readOnly = true)
class MemberQueryService(
    private val memberRepository: MemberRepository
) {
    fun getMemberById(id: Long): Member {
        return memberRepository.findById(id)
            ?: throw MemberNotFoundException(id)
    }
}
```

**Key Principles**:
- Thin service: delegates to repository, throws domain exception
- `@Transactional(readOnly = true)` for read optimization
- Returns domain entity (Member), not DTO
- Reusable across different interfaces (REST, GraphQL, CLI)

#### 4. Interface Layer (New)
- **MemberResponse** DTO for API contract
- **MemberController** handles HTTP concerns
- **Mapper** transforms domain entity to DTO

```kotlin
// interfaces/dto/member/MemberResponse.kt
data class MemberResponse(
    val id: Long,
    val name: String,
    val email: String,              // from Email.value
    val phoneNumber: String,        // from PhoneNumber.masked (privacy!)
    val status: String,             // "ACTIVE" or "WITHDRAWN"
    val pointBalance: Int,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
)

// Extension function for mapping
fun Member.toResponse(): MemberResponse = MemberResponse(
    id = this.id!!,
    name = this.name,
    email = this.email.value,
    phoneNumber = this.phoneNumber.masked,  // Privacy via Value Object!
    status = if (isWithdrawn()) "WITHDRAWN" else "ACTIVE",
    pointBalance = 0,
    createdAt = this.registeredAt,
    updatedAt = this.registeredAt
)
```

```kotlin
// interfaces/rest/member/MemberController.kt
@RestController
@RequestMapping("/api/members")
class MemberController(
    private val memberQueryService: MemberQueryService
) {
    @GetMapping("/{id}")
    fun getMember(@PathVariable id: Long): MemberResponse {
        val member = memberQueryService.getMemberById(id)
        return member.toResponse()
    }

    @ExceptionHandler(MemberNotFoundException::class)
    fun handleNotFound(ex: MemberNotFoundException): ResponseEntity<ErrorResponse> {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ErrorResponse(message = ex.message))
    }
}
```

**Key Principles**:
- Controller is thin: calls service, maps to DTO, handles exceptions
- DTO uses Value Object properties (email.value, phoneNumber.masked)
- Domain exception ‚Üí HTTP status translation happens here
- Privacy enforced via PhoneNumber.masked (e.g., "010-****-5678")

### Dependency Flow

```
Controller (interfaces)
    ‚Üì depends on
Application Service (application)
    ‚Üì depends on
Repository Interface (domain) ‚Üê DEFINED HERE
    ‚Üë implemented by
Repository Impl (infrastructure)
```

**Key Insight**: Domain layer is at the center. All dependencies point inward.

### Data Flow

```
HTTP Request
    ‚Üì
Controller: Parse ID, call service
    ‚Üì
Service: Call repository, throw if not found
    ‚Üì
Repository Impl: Delegate to JPA, convert Optional
    ‚Üì
JPA: Query database
    ‚Üì
Database: Return row
    ‚Üë
JPA: Map to Member entity
    ‚Üë
Repository Impl: Return Member or null
    ‚Üë
Service: Return Member or throw MemberNotFoundException
    ‚Üë
Controller: Catch exception ‚Üí 404 OR map to MemberResponse
    ‚Üë
HTTP Response: JSON with masked phone number
```

### Privacy Pattern

**Problem**: Phone numbers are sensitive and should be partially masked in API responses.

**Solution**: Use PhoneNumber Value Object's `masked` property.

```kotlin
// Domain model defines the capability
@Embeddable
class PhoneNumber(value: String) {
    val value: String = normalize(value)
    val formatted: String = format(value)  // "010-1234-5678"
    val masked: String = mask(value)       // "010-****-5678"
}

// DTO leverages it
fun Member.toResponse() = MemberResponse(
    phoneNumber = this.phoneNumber.masked  // Privacy enforced here
)
```

**Key Insight**: Privacy logic lives in the Value Object, not scattered across DTOs or services.

### Exception Handling Pattern

**Problem**: How to handle "not found" scenario while maintaining layering?

**Solution**: Domain exception + controller translation.

```kotlin
// Domain layer: business language
throw MemberNotFoundException(memberId)

// Interface layer: HTTP translation
@ExceptionHandler(MemberNotFoundException::class)
fun handleNotFound(ex: MemberNotFoundException): ResponseEntity<ErrorResponse> {
    return ResponseEntity.status(404).body(ErrorResponse(message = ex.message))
}
```

**Key Insight**: Domain doesn't know about HTTP. Controller translates domain concepts to HTTP.

## Value Object Pattern

This project uses Value Objects extensively for type safety and domain validation:
- `Email`: Email format validation, immutable
- `PhoneNumber`: Phone number normalization ("01012345678" ‚Üí "010-1234-5678"), masking, carrier detection

Value Objects are embedded using `@Embeddable` and stored in the same table as their parent entity.

## Functional Specifications

Detailed functional specifications are available in:
- [`docs/kbo-ticket-functional-spec.md`](./docs/kbo-ticket-functional-spec.md)

## Testing Guidelines

When writing tests:
- Use Kotest framework for all tests
- Follow BDD style (Given-When-Then)
- Test domain logic independently of infrastructure
- Use test fixtures for complex object creation
- Mock external dependencies appropriately

## Code Style Preferences

- Prefer Kotlin idioms over Java patterns
- Use data classes for DTOs and simple value holders
- Leverage Kotlin's null safety features
- Use extension functions where appropriate
- Keep functions small and focused on single responsibility

## Service Naming Strategy (Updated 2025-10-05)

Ïù¥ ÌîÑÎ°úÏ†ùÌä∏Îäî **UseCaseÏôÄ Domain ServiceÎ•º Î™ÖÌôïÌûà Íµ¨Î∂Ñ**ÌïòÎäî ÎÑ§Ïù¥Î∞ç Ï†ÑÎûµÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.

### UseCase: Îã®Ïùº Aggregate Ï≤òÎ¶¨

**ÏúÑÏπò**: `application/{context}/`
**ÎÑ§Ïù¥Î∞ç**: `{Action}{Aggregate}UseCase.kt`
**Ïó≠Ìï†**: ÌïòÎÇòÏùò AggregateÎ•º Ï§ëÏã¨ÏúºÎ°ú Ìïú Ïú†Ïä§ÏºÄÏù¥Ïä§ Ï≤òÎ¶¨

```kotlin
// application/member/JoinMemberUseCase.kt
@Service
@Transactional
class JoinMemberUseCase(
    private val memberRepository: MemberRepository,
    private val emailService: EmailService
) {
    fun execute(command: JoinMemberCommand): Member {
        // 1. Member Aggregate ÏÉùÏÑ± (ÎèÑÎ©îÏù∏ Î°úÏßÅ)
        val member = Member(
            email = Email(command.email),
            name = command.name,
            phoneNumber = PhoneNumber(command.phoneNumber)
        )

        // 2. Ï†ÄÏû•
        memberRepository.save(member)

        // 3. Ïù¥Î©îÏùº Î∞úÏÜ° (Ïù∏ÌîÑÎùº)
        emailService.sendWelcomeEmail(member)

        return member
    }
}
```

**ÏòàÏãú**:
- `JoinMemberUseCase` - ÌöåÏõê Í∞ÄÏûÖ
- `UpdateMemberUseCase` - ÌöåÏõê Ï†ïÎ≥¥ ÏàòÏ†ï
- `CreateReservationUseCase` - ÏòàÎß§ ÏÉùÏÑ±
- `CancelReservationUseCase` - ÏòàÎß§ Ï∑®ÏÜå

### Domain Service: Ïó¨Îü¨ Aggregate Ï≤òÎ¶¨

**ÏúÑÏπò**: `domain/{context}/service/`
**ÎÑ§Ïù¥Î∞ç**: `{Aggregate}DomainService.kt`
**Ïó≠Ìï†**: Ïó¨Îü¨ AggregateÎ•º Í±∏ÏπòÎäî ÎèÑÎ©îÏù∏ Î°úÏßÅ

```kotlin
// domain/member/service/MemberDomainService.kt
class MemberDomainService(
    private val memberRepository: MemberRepository,
    private val reservationRepository: ReservationRepository
) {
    /**
     * ÌöåÏõê ÌÉàÌá¥ Í∞ÄÎä• Ïó¨Î∂Ä Í≤ÄÏ¶ù
     * MemberÏôÄ Reservation Îëê Aggregate ÏÇ¨Ïö©
     */
    fun canWithdraw(member: Member): Boolean {
        val activeReservations = reservationRepository
            .findActiveByMemberId(member.id!!)
        return activeReservations.isEmpty()
    }

    /**
     * Ïù¥Î©îÏùº Ï§ëÎ≥µ Í≤ÄÏ¶ù
     * Îã®Ïùº AggregateÏßÄÎßå Repository Ï°∞ÌöåÍ∞Ä ÌïÑÏöîÌïú ÎèÑÎ©îÏù∏ Í∑úÏπô
     */
    fun validateUniqueEmail(email: Email) {
        if (memberRepository.existsByEmail(email)) {
            throw DuplicateEmailException(email)
        }
    }
}
```

**ÏòàÏãú**:
- `MemberDomainService` - ÌöåÏõê Í¥ÄÎ†® ÎèÑÎ©îÏù∏ Î°úÏßÅ
- `ReservationDomainService` - ÏòàÎß§ Í¥ÄÎ†® ÎèÑÎ©îÏù∏ Î°úÏßÅ
- `SeatAllocationService` - Ï¢åÏÑù Î∞∞Ï†ï Î°úÏßÅ

### Query Service: Ï°∞Ìöå Ï†ÑÏö© (CQRS)

**ÏúÑÏπò**: `application/{context}/`
**ÎÑ§Ïù¥Î∞ç**: `{Aggregate}QueryService.kt`
**Ïó≠Ìï†**: ÏùΩÍ∏∞ Ï†ÑÏö© Ï°∞Ìöå

```kotlin
// application/member/MemberQueryService.kt
@Service
@Transactional(readOnly = true)
class MemberQueryService(
    private val memberRepository: MemberRepository
) {
    fun getMemberById(id: Long): Member {
        return memberRepository.findById(id)
            ?: throw MemberNotFoundException(id)
    }
}
```

**ÏòàÏãú**:
- `MemberQueryService` - ÌöåÏõê Ï°∞Ìöå
- `ReservationQueryService` - ÏòàÎß§ Ï°∞Ìöå
- `PerformanceQueryService` - Í≥µÏó∞ Ï°∞Ìöå

### UseCaseÏóêÏÑú Domain Service ÏÇ¨Ïö©

```kotlin
// application/member/WithdrawMemberUseCase.kt
@Service
@Transactional
class WithdrawMemberUseCase(
    private val memberRepository: MemberRepository,
    private val memberDomainService: MemberDomainService  // Domain Service Ï£ºÏûÖ
) {
    fun execute(memberId: Long) {
        val member = memberRepository.findById(memberId)
            ?: throw MemberNotFoundException(memberId)

        // Domain ServiceÎ°ú Í≤ÄÏ¶ù ÏúÑÏûÑ (Ïó¨Îü¨ Aggregate Í≤ÄÏ¶ù)
        if (!memberDomainService.canWithdraw(member)) {
            throw CannotWithdrawException("ÏßÑÌñâÏ§ëÏù∏ ÏòàÎß§Í∞Ä ÏûàÏäµÎãàÎã§")
        }

        // Member AggregateÏùò ÎèÑÎ©îÏù∏ Î°úÏßÅ
        member.withdraw()
        memberRepository.save(member)
    }
}
```

### Ï†ÑÏ≤¥ Íµ¨Ï°∞ ÏòàÏãú

```
src/main/kotlin/com/innovation/dddexample/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ member/
‚îÇ       ‚îú‚îÄ‚îÄ model/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Member.kt              # Aggregate Root
‚îÇ       ‚îú‚îÄ‚îÄ repository/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ MemberRepository.kt    # Repository Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
‚îÇ       ‚îî‚îÄ‚îÄ service/
‚îÇ           ‚îî‚îÄ‚îÄ MemberDomainService.kt # Domain Service (Ïó¨Îü¨ Aggregate)
‚îÇ
‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îî‚îÄ‚îÄ member/
‚îÇ       ‚îú‚îÄ‚îÄ MemberQueryService.kt      # Query (Ï°∞Ìöå)
‚îÇ       ‚îú‚îÄ‚îÄ JoinMemberUseCase.kt       # UseCase (Í∞ÄÏûÖ)
‚îÇ       ‚îú‚îÄ‚îÄ UpdateMemberUseCase.kt     # UseCase (ÏàòÏ†ï)
‚îÇ       ‚îî‚îÄ‚îÄ WithdrawMemberUseCase.kt   # UseCase (ÌÉàÌá¥, Domain Service ÏÇ¨Ïö©)
‚îÇ
‚îî‚îÄ‚îÄ interfaces/rest/member/
    ‚îî‚îÄ‚îÄ MemberController.kt            # REST Controller
```

### ÎÑ§Ïù¥Î∞ç Í≤∞Ï†ï Í∏∞Ï§Ä

| ÏÉÅÌô© | ÏÑ†ÌÉù | ÏòàÏãú |
|------|------|------|
| Îã®Ïùº AggregateÎßå ÏÇ¨Ïö© | `~UseCase` | `JoinMemberUseCase` |
| Ïó¨Îü¨ Aggregate Í±∏Ïπ® | `~DomainService` | `MemberDomainService` |
| Ï°∞ÌöåÎßå (CQRS Query) | `~QueryService` | `MemberQueryService` |

## Agent Workflow Addendum (2025-10-05)

- ÎèÑÎ©îÏù∏ ÏûëÏóÖ Ï∞©Ïàò Ï†Ñ, Ìï¥Îãπ ÎèÑÎ©îÏù∏ Í≤ΩÎ°ú(Ïòà: `src/main/kotlin/com/innovation/dddexample/domain/member/`)Ïóê ÏöîÍµ¨ Ï†ïÎ¶¨Ïö© MarkdownÏùÑ ÏÉùÏÑ±Ìï¥ ÏßÄÏπ®ÏÑúÎ•º Ïú†ÏßÄÌïúÎã§.
- ÏöîÍµ¨ Ï†ïÎ¶¨Îäî Aggregate Íµ¨Ï°∞, ÌïÑÏàò Repository Í∏∞Îä•, Í∏∞Îä• Î™ÖÏÑ∏ Ïó∞Í≥Ñ Ìè¨Ïù∏Ìä∏, ÌÖåÏä§Ìä∏ Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏, Ïó¥Î¶∞ Ïù¥ÏäàÎ•º ÏµúÏÜå Ìï≠Î™©ÏúºÎ°ú Ìè¨Ìï®ÌïúÎã§.
- ÏÉà ÏßÄÏπ®ÏÑúÎäî `docs`ÏôÄ ÏÜåÏä§ Í≤ΩÎ°ú Î™®ÎëêÏóêÏÑú Ï∞∏Ï°∞ Í∞ÄÎä•ÌïòÎèÑÎ°ù ÌååÏùºÎ™ÖÏùÑ Î™ÖÌôïÌûà ÌïòÍ≥†, Ïù¥ÌõÑ Íµ¨ÌòÑ Îã®Í≥ÑÎäî Ìï¥Îãπ ÏßÄÏπ®ÏùÑ Í∑ºÍ±∞Î°ú ÏßÑÌñâÌïúÎã§.
